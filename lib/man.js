"use strict";

var ast = require('mkast')
  , Node = ast.Node
  , Renderer = ast.Renderer
  , manual = require('manual')
  , prefix = require('./prefix-lines')
  , normalize = require('./normalize')
  , Links = require('./links')
  , repeat = require('string-repeater');

var macros = {
  hr: '.de hr\n.nf\n.ce\n.in 4\n\\l’80’\n.fi\n..\n',
  h1: '.rn SH h1\n',
  h2: '.rn SS h2\n',
  h3: '.de h3\n.in 7\n.sp 1\n\\fB\\\\$1\\fR\n..\n',

//.de h3
//.in 7
//.sp 1
//\fB\\$1\fR
//..
}

/**
 *  Renders an abstract syntax tree to a ROFF man page.
 *
 *  @constructor ManRenderer
 *  @param {Object} [opts] processing options.
 */
function ManRenderer(opts) {
  opts = opts || {};
  Renderer.call(this);

  // automatically convert links to numbered references
  this.autolink = opts.autolink !== undefined ? opts.autolink : true;

  // list of links encountered during the render
  this.links = new Links();

  this.opts = opts;
  this.newline = opts.newline || '.br\n';
  this.section = opts.section || '1';
  this.description = opts.description || '';

  this.locale = opts.locale || 'en-gb';

  this.blockquote = '|';

  // how to treat inline code, may be `emph` or `strong`
  // any other results in no formatting for inline code
  this.inline = opts.inline !== undefined ? opts.inline : Node.STRONG;

  // force inclusion of inline and block HTML when set
  this.html = opts.html !== undefined ? opts.html : false;
}

function document(node, entering) {
  if(entering) {

    var d = new Date()
      , locale = this.locale
      , opts = {
        title: this.title || 'UNTITLED',
        section: this.section,
        description: this.description,
        comment: 'Generated by mkdoc on ' + d,
        date: d.toLocaleString(locale, {month: 'long'})
          + ', ' + d.toLocaleString(locale, {year: 'numeric'})
      }

    var preamble = manual.preamble(opts);

    this.out(preamble);

    // add macros
    for(var k in macros) {
      this.out(macros[k]); 
    }
  }else{
    this.thematic_break(node, entering);
    this.out('\n');
    this.cr();
    // print link references by index
    this.out(this.links.list('\n' + this.newline));
  }
}

function text(node) {
  // required to show inline backslashes, eg: '`\fB`'
  var str = node.literal.replace(/[\\\\]{1,1}/g, '\\\\');
  str = manual.sanitize(str);

  if(!this.autolink) {
    return this.out(str); 
  }

  var p = node.parent
    , grandparent = p.parent
    , dest = '';

  // NOTE: this captures link parents when the hierarchy is:
  // NOTE: link > image > text
  while(p) {
    if(Node.is(p, Node.LINK)) {
      dest = p.destination;
      break;
    }
    p = p.parent;
  }

  if(grandparent && Node.is(grandparent, Node.BLOCK_QUOTE)) {
    this.out(prefix(node, str, this.blockquote, true));
  }else if(dest) {
    this.out(str + '[' + (this.links.destinations[dest] + 1) + ']');
  }else{
    this.lit(str);
  }
}

function softbreak(node/*, entering*/) {
  var grandparent = node.parent ? node.parent.parent : null;
  // preserve soft line breaks in block quotes
  if(grandparent
    && Node.is(grandparent, Node.BLOCK_QUOTE)) {
    this.out('\n');
    this.cr();
    return; 
  }

  // output single space for soft line breaks unless preserved
  if(node.prev && Node.is(node.prev, Node.TEXT)) {
    if(!/ $/.test(node.prev.literal)) {
      this.out(' '); 
    } 
  }
}

function linebreak() {
  //this.out(this.options.linebreak);
  this.cr();
}

function link(node, entering) {
  // track links in the document, so that they can be printed
  // when the document is closed and so that the `text` handling
  // can append a link index to the literal in the form: link[1]
  if(entering && this.autolink) {
    this.links.add(node);
  }
}

// function image(node, entering) {}

function emph(node, entering) {
  if(entering) {
    this.out('\\fI'); 
  }else{
    this.out('\\fR'); 
  }
}

function strong(node, entering) {
  if(entering) {
    this.out('\\fB'); 
  }else{
    this.out('\\fR'); 
  }
}

function code(node) {
  if(this.inline && typeof this[this.inline] === 'function') {
    this[this.inline](node, true); 
    this.text(node); 
    this[this.inline](node, false); 
  }
}

function paragraph(node, entering) {
  var grandparent = node.parent ? node.parent.parent : null;
  if(grandparent
      && Node.is(grandparent, Node.LIST)
      && grandparent.listTight) {
        return;
  }
  if(entering) {
    if(!node.parent || !Node.is(node.parent, Node.BLOCK_QUOTE)) {
      this.out('.PP\n');
    }
  }else if(!entering) {
    this.out('\n');
    this.cr(2);
  }
}

function heading(node, entering) {
  if(entering) {
    this.out('.h' + node.level + ' "')
    //if(node.level === 1) {
      //this.out('.h1 "');
    //}else{
      //this.out('.h2 "');
    //}
  }else{
    this.out('"\n');
  }
}

function code_block(node, entering) {
  if(entering) {
    this.out('.PP\n.in 10\n');
    this.text(node);
  }else{
    this.cr(2);
  }
}

function thematic_break() {
  this.out('.hr\n');
}

function block_quote(node, entering) {
  if(entering) {
    this.out('.PP\n.in 10\n');
  }else{
    this.cr(2);
  }
}

function list(node, entering) {
  if(entering) {
    this.out('.BL\n');
  }else{
    this.out('.EL\n');
  }
}

function item(node, entering) {
  if(entering) {
    this.out('.IP "\\[ci]" 4\n');
  }else{
    this.out('\n');
    this.cr();
  }
}

function html_block(node, entering) {
  if(this.html) {
    if(entering) {
      this.text(node);
    }else{
      this.out('\n');
      this.cr(2);
    }
  }else{
    node.literal = normalize(node.literal);
    this.out('.PP\n');
    this.text(node);
    this.out('\n');
    this.cr(2);
  }
}

function html_inline(node, entering) {
  if(this.html) {
    if(entering) {
      this.text(node);
    }
  }else{
    node.literal = normalize(node.literal);
    this.text(node);
  }
}

function custom_inline(node, entering) {
  if(entering && node.onEnter) {
    this.out(node.onEnter);
  }else if(!entering && node.onExit) {
    this.out(node.onExit);
  }
}

function custom_block(node, entering) {
  this.custom_inline(node, entering);
  this.cr(2);
}

/* Helper methods */

function cr(amount) {
  if(amount === undefined) {
    this.lit(this.newline);
  }else if(amount) {
    this.lit(repeat(this.newline, amount));
  }
}

function render() {
  // reset so renderer is re-usable
  this.links.reset();
  return Renderer.prototype.render.apply(this, arguments);
}

ManRenderer.prototype = Object.create(Renderer.prototype);

ManRenderer.prototype.render = render;

ManRenderer.prototype.document = document;
ManRenderer.prototype.text = text;
ManRenderer.prototype.html_inline = html_inline;
ManRenderer.prototype.html_block = html_block;
ManRenderer.prototype.softbreak = softbreak;
ManRenderer.prototype.linebreak = linebreak;
ManRenderer.prototype.link = link;
//ManRenderer.prototype.image = image;
ManRenderer.prototype.emph = emph;
ManRenderer.prototype.strong = strong;
ManRenderer.prototype.paragraph = paragraph;
ManRenderer.prototype.heading = heading;
ManRenderer.prototype.code = code;
ManRenderer.prototype.code_block = code_block;
ManRenderer.prototype.thematic_break = thematic_break;
ManRenderer.prototype.block_quote = block_quote;
ManRenderer.prototype.list = list;
ManRenderer.prototype.item = item;
ManRenderer.prototype.custom_inline = custom_inline;
ManRenderer.prototype.custom_block = custom_block;
ManRenderer.prototype.cr = cr;

module.exports = ManRenderer;
